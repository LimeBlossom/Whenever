using System;
using System.Collections.Generic;
using System.Linq;
using CoreFac;

public record Whenever<TInspectWorld, TCommandWorld> : IDescribableWithConcreteContext
    where TInspectWorld : IInspectWorld
    where TCommandWorld : ICommandWorld
{
    public readonly IWheneverFilter<TInspectWorld, TCommandWorld> filter;
    public readonly IEffect<TInspectWorld, TCommandWorld> effect;

    private readonly IAliasCombatantIds bakedAliaser;
    
    /// <summary>
    /// a unique id. will be unique for each unique whenever contained inside a wheneverManager.
    /// </summary>
    public Guid Id { get; private set; } = Guid.NewGuid();

    public Whenever(
        IWheneverFilter<TInspectWorld, TCommandWorld> filter,
        IEffect<TInspectWorld, TCommandWorld> effect,
        IAliasCombatantIds bakedAliases = null)
    {
        this.filter = filter;
        this.effect = effect;
        this.bakedAliaser = bakedAliases;
    }

    /// <summary>
    /// Will return a new whenever which has baked-in the provided combatant aliases. Useful to bake in permanent context
    ///     such as "the caster of the card which caused this whenever"
    /// </summary>
    /// <param name="aliases"></param>
    /// <param name="assumeAlreadyBaked">
    /// When true, will assume the given alias is already baked and will share a reference to the provided aliaser.
    /// Use this if we want to share a baked aliaser between multiple whenever instances, without allocating extra
    /// </param>
    /// <returns></returns>
    public Whenever<TInspectWorld, TCommandWorld> BakeCombatantAlias(IAliasCombatantIds aliases, bool assumeAlreadyBaked = false)
    {
        var bakedAliases = assumeAlreadyBaked ? aliases : aliases.BakeInto();
        return new Whenever<TInspectWorld, TCommandWorld>(filter, effect, bakedAliases);
    }
    
    public bool TriggersOn(
        InitiatedCommand<TCommandWorld> command,
        IAliasCombatantIds baseAliaser,
        TInspectWorld world)
    {
        // TODO performance: a large amount of garbage is generated by this approach, in both filtering and effecting.
        var overrideAliaser = baseAliaser
            .OverrideWith(bakedAliaser)
            .OverrideWithCommandContext(command);
        return filter.TriggersOn(command, overrideAliaser, world);
    }

    public IEnumerable<InitiatedCommand<TCommandWorld>> GetTriggeredCommands(
        InitiatedCommand<TCommandWorld> command,
        IAliasCombatantIds baseAliaser,
        TInspectWorld world)
    {
        var overrideAliaser = baseAliaser
            .OverrideWith(bakedAliaser)
            .OverrideWithCommandContext(command);
        if (!filter.TriggersOn(command, overrideAliaser, world)) return Enumerable.Empty<InitiatedCommand<TCommandWorld>>();

        var nextInitiator = Initiators.FromEffectOf(command.initiator);
            
        return effect
            .ApplyEffect(command, overrideAliaser, world)
            .Select(x => new InitiatedCommand<TCommandWorld>(x, nextInitiator));
    }
    internal Whenever<TInspectWorld, TCommandWorld> ForceRegenerateIdentifier()
    {
        return this with
        {
            Id = Guid.NewGuid()
        };
    }
    public string Describe(DescribeWithAliases context)
    {
        var overridenContext = context.WithAliasOverride(bakedAliaser);
        return $"When {filter.Describe(overridenContext)}; {effect.Describe(overridenContext)}";
    }
}