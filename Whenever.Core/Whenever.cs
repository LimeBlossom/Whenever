using System;
using System.Collections.Generic;
using System.Linq;
using CoreFac;

public record Whenever<TInspectWorld, TCommandWorld> : IDescribableWithConcreteContext
    where TInspectWorld : IInspectWorld
    where TCommandWorld : ICommandWorld
{
    public readonly IWheneverFilter<TInspectWorld, TCommandWorld> filter;
    public readonly IEffect<TInspectWorld, TCommandWorld> effect;

    private readonly IAliasCombatantIds aliaser;
    
    /// <summary>
    /// a unique id. will be unique for each unique whenever contained inside a wheneverManager.
    /// </summary>
    public Guid Id { get; private set; } = Guid.NewGuid();

    public Whenever(
        IWheneverFilter<TInspectWorld, TCommandWorld> filter,
        IEffect<TInspectWorld, TCommandWorld> effect,
        IAliasCombatantIds bakedAliases = null)
    {
        this.filter = filter;
        this.effect = effect;
        this.aliaser = bakedAliases;
    }
    
    /// <summary>
    /// Will return a new whenever which has baked-in the provided combatant aliases. Useful to bake in permanent context
    ///     such as "the caster of the card which caused this whenever"
    /// </summary>
    /// <param name="aliases"></param>
    /// <returns></returns>
    public Whenever<TInspectWorld, TCommandWorld> BakeCombatantAlias(IAliasCombatantIds aliases)
    {
        return new Whenever<TInspectWorld, TCommandWorld>(filter, effect, aliases);
    }
    
    public bool TriggersOn(
        InitiatedCommand<TCommandWorld> command,
        IAliasCombatantIds baseAliaser,
        TInspectWorld world)
    {
        // TODO performance: a large amount of garbage is generated by this approach, in both filtering and effecting.
        var overrideAliaser = baseAliaser
            .OverrideWith(aliaser)
            .OverrideWithCommandContext(command);
        return filter.TriggersOn(command, overrideAliaser, world);
    }

    public IEnumerable<InitiatedCommand<TCommandWorld>> GetTriggeredCommands(
        InitiatedCommand<TCommandWorld> command,
        IAliasCombatantIds baseAliaser,
        TInspectWorld world)
    {
        var overrideAliaser = baseAliaser
            .OverrideWith(aliaser)
            .OverrideWithCommandContext(command);
        if (!filter.TriggersOn(command, overrideAliaser, world)) return Enumerable.Empty<InitiatedCommand<TCommandWorld>>();

        var nextInitiator = Initiators.FromEffectOf(command.initiator);
            
        return effect
            .ApplyEffect(command, overrideAliaser, world)
            .Select(x => new InitiatedCommand<TCommandWorld>(x, nextInitiator));
    }
    internal Whenever<TInspectWorld, TCommandWorld> ForceRegenerateIdentifier()
    {
        return this with
        {
            Id = Guid.NewGuid()
        };
    }
    public string Describe(DescribeWithAliases context)
    {
        // TODO: better way to compose all these. or don't allow accepting an external alias at all?
        var overridenContext = context.WithAliasOverride(this.aliaser);
        return $"When {filter.Describe(overridenContext)}; {effect.Describe(overridenContext)}";
    }
}